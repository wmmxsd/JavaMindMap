# 类加载器

## 作用

1. 在类加载过程的加载阶段通过类的完全限定名读取class文件到二进制字节流，然后在方法区生成一个该类的运行时数据结构。
2. 在堆中创建一个该类的Class对象实例。

## 内置加载器

### `BootStrap ClassLoader`

&emsp;使用C++语言实现的，是虚拟机自身的一部分，它负责将`<JAVA_HOME>/lib`路径下的核心类库或`-Xbootclasspath`参数指定的路径下的jar包加载到内存中。

### `Extension ClassLoader`

&emsp;由Java语言实现的，是Launcher的静态内部类，它负责加载`<JAVA_HOME>/lib/ext`目录下或者由系统变量`-Djava.ext.dir`指定位路径中的类库，开发者可以直接使用标准扩展类加载器。

### `Application ClassLoader`

&emsp;它负责加载系统类路径`java -classpath`或`-D java.class.path`指定路径下的类库，也就是我们经常用到的`classpath`路径，开发者可以直接使用系统类加载器，一般情况下该类加载是程序中默认的类加载器，通过`ClassLoader#getSystemClassLoader()`方法可以获取到该类加载器。

## 双亲委派模式

![双亲委派模式](../../pictures/双亲委派模式.png)

### 工作原理

&emsp;在类加载的时候，系统会首先判断当前类是否被加载过。已经被加载的类会直接返回，否则才会尝试加载。加载的时候，首先会把该请求委派该父类加载器的`loadClass()`处理，因此所有的请求最终都应该传送到顶层的启动类加载器`BootstrapClassLoader`中。当父类加载器无法处理时，才由自己来处理。当父类加载器为`null`时，会使用启动类加载器`BootstrapClassLoader`作为父类加载器。

每个类加载都有一个父类加载器，我们通过下面的程序来验证。

```java
public class ClassLoaderDemo {
    public static void main(String[] args) {
        System.out.println("ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader());
        System.out.println("The Parent of ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader().getParent());
        System.out.println("The GrandParent of ClassLodarDemo's ClassLoader is " + ClassLoaderDemo.class.getClassLoader().getParent().getParent());
    }
}
```

```log
Output
ClassLodarDemo's ClassLoader is sun.misc.Launcher$AppClassLoader@18b4aac2
The Parent of ClassLodarDemo's ClassLoader is sun.misc.Launcher$ExtClassLoader@1b6d3586
The GrandParent of ClassLodarDemo's ClassLoader is null
```

**`AppClassLoader`的父类加载器为`ExtClassLoader`，`ExtClassLoader`的父类加载器为`null`，`null`并不代表`ExtClassLoader`没有父类加载器，而是`BootstrapClassLoader`。**

### 优势

1. 避免重复加载相同类。
2. 核心API防篡改。

## 源码分析

![类加载器类图](../../pictures/JVM自带类加载器类图.png)

## 类与类加载器的关系

### 两个class对象为同一个类对象的两个必要条件

1. 类的全类名相同。
2. 加载该类的类加载器实例对象必须相同，但前提是该类加载器覆写`loadclass()`方法，因为该方法会先从缓存查找该类是否已被加载，如果被加载直接返回已被加载的Class对象实例。

### loadClass()

## 自定义加载器
